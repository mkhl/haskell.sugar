<?xml version="1.0" encoding="UTF-8"?>
<action-recipes>

<!--
    TODO:
    - guard
    - typedecl
    - bind
    - lambda
    - typedecl-func
    - typedecl-class
    - class
    - instance
    - type
    - newtype
    - data
-->
    <snippet id="org.purl.net.mkhl.haskell.snippets.shebang" category="tools.Snippets">
        <title>#!â€¦</title>
        <text><![CDATA[#!/usr/bin/env ${1:runhaskell}
]]></text>
        <text-trigger>#!</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

    <snippet id="org.purl.net.mkhl.haskell.snippets.module" category="tools.Snippets">
        <title>module</title>
        <text><![CDATA[module ${1:Main} ${2/.+/(
	/}${2:main}${2/.+/
) /}where

${0:definitions}]]></text>
        <text-trigger>mod</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.import.default" category="tools.Snippets">
	    <title>import</title>
	    <text><![CDATA[import ${1:Module}${2/.+/ (/}${2:function}${2/.+/)/}]]></text>
	    <text-trigger>imp</text-trigger>
	    <syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.import.hiding" category="hide">
	    <title>import</title>
	    <text><![CDATA[import ${1:Module}${2/.+/ hiding (/}${2:function}${2/.+/)/}]]></text>
	    <text-trigger>imph</text-trigger>
	    <syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.import.qualified" category="hide">
	    <title>import</title>
	    <text><![CDATA[import qualified ${1:Module}${2/.+/ as /}${2:Mod}${2/.+/ /}${3/.+/ (/}${3:function}${3/.+/)/}]]></text>
	    <text-trigger>impq</text-trigger>
	    <syntax-context>haskell, haskell *</syntax-context>
	</snippet>

    <snippet id="org.purl.net.mkhl.haskell.snippets.if-block" category="tools.Snippets">
        <title>if block</title>
        <text><![CDATA[if ${1:condition}
	then ${2:expression}
	else ${0:expression}]]></text>
        <text-trigger>if</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

    <snippet id="org.purl.net.mkhl.haskell.snippets.case-block" category="tools.Snippets">
        <title>case block</title>
        <text><![CDATA[case ${1:expression} in
	${2:pattern} -> ${3:expression}
	${4:otherwise} -> ${0:expression}]]></text>
        <text-trigger>case</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

    <snippet id="org.purl.net.mkhl.haskell.snippets.let-block" category="tools.Snippets">
        <title>let block</title>
        <text><![CDATA[let
		${1:x} = ${2:expression}
	in ${0:expression}]]></text>
        <text-trigger>let</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

    <snippet id="org.purl.net.mkhl.haskell.snippets.where-block" category="tools.Snippets">
        <title>where block</title>
        <text><![CDATA[where
	${1:x} = ${0:expression}]]></text>
        <text-trigger>where</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

    <snippet id="org.purl.net.mkhl.haskell.snippets.do-block" category="tools.Snippets">
        <title>do block</title>
        <text><![CDATA[do
	${1:return ${0:expression}}]]></text>
        <text-trigger>do</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

</action-recipes>