<?xml version="1.0" encoding="UTF-8"?>
<action-recipes>

<!--
    TODO:
    - guard
    - typedecl
    - bind
    - lambda
    - typedecl-func
    - typedecl-class
    - class
    - instance
-->
<!--Metadata-->
    <snippet id="org.purl.net.mkhl.haskell.snippets.shebang" category="tools.Snippets">
        <title>#!â€¦</title>
        <text><![CDATA[#!/usr/bin/env ${1:runhaskell}
]]></text>
        <text-trigger>#!</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.haddock.prefix.block" category="hide">
		<title>Haddock comment (block)</title>
		<text><![CDATA[{-| ${0:documentation}
-}]]></text>
		<text-trigger>{-|</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.haddock.prefix.line" category="hide">
		<title>Haddock comment (prefix)</title>
		<text><![CDATA[--| ${0:documentation}]]></text>
		<text-trigger>--|</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.haddock.postfix.line" category="hide">
		<title>Haddock comment (postfix)</title>
		<text><![CDATA[--^ ${0:documentation}]]></text>
		<text-trigger>--^</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

<!--Module structure-->
    <snippet id="org.purl.net.mkhl.haskell.snippets.module" category="tools.Snippets">
        <title>module</title>
        <text><![CDATA[module ${1:Main} ${2/.+/(
	/}${2:function}${2/.+/
) /}where

${0:definitions}]]></text>
        <text-trigger>mod</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.import.default" category="tools.Snippets">
	    <title>import</title>
	    <text><![CDATA[import ${1:Module}${2/.+/ (/}${2:function}${2/.+/)/}]]></text>
	    <text-trigger>imp</text-trigger>
	    <syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.import.hiding" category="hide">
	    <title>import</title>
	    <text><![CDATA[import ${1:Module}${2/.+/ hiding (/}${2:function}${2/.+/)/}]]></text>
	    <text-trigger>imph</text-trigger>
	    <syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.import.qualified" category="hide">
	    <title>import</title>
	    <text><![CDATA[import qualified ${1:Module}${2/.+/ as /}${2:Mod}${2/.+/ /}${3/.+/ (/}${3:function}${3/.+/)/}]]></text>
	    <text-trigger>impq</text-trigger>
	    <syntax-context>haskell, haskell *</syntax-context>
	</snippet>

<!--Datatypes-->
	<snippet id="org.purl.net.mkhl.haskell.snippets.type" category="tools.Snippets">
		<title>type</title>
		<text><![CDATA[type ${1:Type} = ${2:Other}]]></text>
		<text-trigger>typ</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.newtype" category="tools.Snippets">
		<title>newtype</title>
		<text><![CDATA[newtype ${1:Type} = ${2:Other}]]></text>
		<text-trigger>new</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.data" category="tools.Snippets">
		<title>data</title>
		<text><![CDATA[data ${1:Type} = ${2:Other}]]></text>
		<text-trigger>dat</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.deriving" category="tools.Snippets">
		<title>deriving</title>
		<text><![CDATA[deriving (${1:Class})]]></text>
		<text-trigger>der</text-trigger>
		<syntax-context>haskell container.type.data, haskell container.type.data *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.class" category="tools.Snippets">
		<title>class</title>
		<text><![CDATA[class ${1:Class}${2/.+/ where
	/}${2:definition}]]></text>
		<text-trigger>cla</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.instance" category="tools.Snippets">
		<title>instance</title>
		<text><![CDATA[instance ${1:Class} ${2:Type}${3/.+/ where
	/}${3:definition}]]></text>
		<text-trigger>ins</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

<!--Code blocks-->
    <snippet id="org.purl.net.mkhl.haskell.snippets.if-block" category="tools.Snippets">
        <title>if block</title>
        <text><![CDATA[if ${1:condition}
	then ${2:expression}
	else ${0:expression}]]></text>
        <text-trigger>if</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

    <snippet id="org.purl.net.mkhl.haskell.snippets.case-block" category="tools.Snippets">
        <title>case block</title>
        <text><![CDATA[case ${1:expression} in
	${2:pattern} -> ${3:expression}
	${4:otherwise} -> ${0:expression}]]></text>
        <text-trigger>case</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

    <snippet id="org.purl.net.mkhl.haskell.snippets.let-block" category="tools.Snippets">
        <title>let block</title>
        <text><![CDATA[let
		${1:x} = ${2:expression}
	in ${0:expression}]]></text>
        <text-trigger>let</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

    <snippet id="org.purl.net.mkhl.haskell.snippets.where-block" category="tools.Snippets">
        <title>where block</title>
        <text><![CDATA[where
	${1:x} = ${0:expression}]]></text>
        <text-trigger>where</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

    <snippet id="org.purl.net.mkhl.haskell.snippets.do-block" category="tools.Snippets">
        <title>do block</title>
        <text><![CDATA[do
	${1:return ${0:expression}}]]></text>
        <text-trigger>do</text-trigger>
        <syntax-context>haskell, haskell *</syntax-context>
    </snippet>

<!--Miscellaneous-->
	<snippet id="org.purl.net.mkhl.haskell.snippets.lambda-expression" category="hide">
		<title>lambda expression</title>
		<text><![CDATA[\ ${1:name} -> ${0:expression]]></text>
		<text-trigger>\</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.arrow-left" category="hide">
		<title>left arrow</title>
		<text><![CDATA[${1:name} <- ${0:expression]]></text>
		<text-trigger>&lt;</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.arrow-right" category="hide">
		<title>right arrow</title>
		<text><![CDATA[${1:expression} -> ${0:expression]]></text>
		<text-trigger>></text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

	<snippet id="org.purl.net.mkhl.haskell.snippets.list-comprehension" category="hide">
		<title>list comprehension</title>
		<text><![CDATA[[ ${1:name} | $1 <- ${2:expression}#{3/.+/, /}${3:condition} ]]></text>
		<text-trigger>[</text-trigger>
		<syntax-context>haskell, haskell *</syntax-context>
	</snippet>

</action-recipes>